"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ng2ProcessTree = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const read_into_source_file_1 = require("./read-into-source-file");
const ts = require("@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript");
const change_1 = require("@schematics/angular/utility/change");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const workspace_1 = require("@schematics/angular/utility/workspace");
const schematics_2 = require("@angular/cdk/schematics");
function ng2ProcessTree(options, newCode, newMarkup, newImports = []) {
    return (tree) => __awaiter(this, void 0, void 0, function* () {
        const workspace = yield workspace_1.getWorkspace(tree);
        const projectName = options.project || workspace.extensions.defaultProject;
        const project = workspace.projects.get(projectName);
        if (!project) {
            throw new schematics_1.SchematicsException(`Unable to find project '${project}' in the workspace`);
        }
        const buildOptions = schematics_2.getProjectTargetOptions(project, 'build');
        options.module = ng_ast_utils_1.getAppModulePath(tree, buildOptions.main);
        const codeAction = tree.actions.filter(r => r.path.endsWith('.component.ts'))[0];
        const markupActions = tree.actions.filter(r => r.path.endsWith('.component.html'));
        const codeSource = read_into_source_file_1.readIntoSourceFile(tree, codeAction.path);
        const nodes = ast_utils_1.getSourceNodes(codeSource);
        const classNodes = nodes.filter(r => ast_utils_1.findNodes(r, ts.SyntaxKind.ClassDeclaration).length);
        const classDecl = ast_utils_1.findNodes(classNodes[0], ts.SyntaxKind.ClassDeclaration)[0];
        let inlineTemplate = false;
        let template;
        const changes = newImports.map(([a, b]) => ast_utils_1.insertImport(codeSource, codeAction.path, a, b));
        const projectRecorder = tree.beginUpdate(codeAction.path);
        if (classDecl.decorators) {
            const decorator = classDecl.decorators[0];
            const literal = ast_utils_1.findNodes(decorator.expression, ts.SyntaxKind.ObjectLiteralExpression)[0];
            template = literal.properties.filter(r => ts.isPropertyAssignment(r) &&
                ts.isIdentifier(r.name) &&
                r.name.escapedText === 'template')[0];
            if (template) {
                const newNode = ts.factory.createStringLiteral('`' + newMarkup + '`');
                const start = template.initializer.getStart();
                const end = template.initializer.getEnd();
                projectRecorder.remove(start, end - start);
                projectRecorder.insertLeft(start, newNode.text);
                inlineTemplate = true;
            }
        }
        if (!inlineTemplate && markupActions.length) {
            const markupAction = markupActions[0];
            tree.overwrite(markupAction.path, newMarkup);
        }
        const start2 = classDecl.members[0].getStart();
        const end2 = classDecl.members[classDecl.members.length - 1].getEnd();
        projectRecorder.remove(start2, end2 - start2);
        projectRecorder.insertLeft(start2, newCode);
        for (const change of changes) {
            if (change instanceof change_1.InsertChange) {
                projectRecorder.insertLeft(change.pos, change.toAdd);
            }
        }
        if (options.module) {
            const moduleSource = read_into_source_file_1.readIntoSourceFile(tree, options.module);
            const addImport = ast_utils_1.addImportToModule(moduleSource, options.module, 'NgChartsModule', 'ng2-charts');
            const moduleRecorder = tree.beginUpdate(options.module);
            for (const change of addImport) {
                if (change instanceof change_1.InsertChange) {
                    moduleRecorder.insertLeft(change.pos, change.toAdd);
                }
            }
        }
        tree.commitUpdate(projectRecorder);
    });
}
exports.ng2ProcessTree = ng2ProcessTree;
//# sourceMappingURL=ng2-process-tree.js.map